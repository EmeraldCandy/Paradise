// the steps for repairing the reactor
#define REACTOR_NEEDS_DIGGING 		1
#define REACTOR_NEEDS_CROWBAR 		2
#define REACTOR_NEEDS_PLASTITANIUM	3
#define REACTOR_NEEDS_SCREWDRIVER	4
#define REACTOR_NEEDS_WELDING		5
#define REACTOR_NEEDS_PLASTEEL		6
#define REACTOR_NEEDS_WRENCH		7

// The states of reactor chambers
#define CHAMBER_DOWN	 1
#define CHAMBER_UP		 2
#define CHAMBER_OPEN	 3

#warn Idea todo: Make plutonium nuke core craftable

/obj/machinery/power/fission_reactor
	name = "Nuclear Fission Reactor"
	desc = "An ancient yet reliable form of power generation utilising fissile materials to generate heat."
	icon = 'icons/goonstation/objects/reactor.dmi'
	icon_state = "reactor_off"
	anchored = TRUE
	density = TRUE
	resistance_flags = INDESTRUCTIBLE | LAVA_PROOF | FIRE_PROOF | UNACIDABLE | ACID_PROOF | FREEZE_PROOF
	pixel_x = -16

	/// Holds the list for the connected reactor chambers to take data from
	var/list/connected_chambers = list()
	/// Prevents the reactor from making power under certain circumstances
	var/can_create_power = TRUE
	/// The total amount of heat gathered in the reactor
	var/total_heat
	/// The total amount of power being generated by the engine (in watts)
	var/total_power
	/// The user-controlled rods used to change how active the reactor is
	var/control_rod_percentage = 0
	/// A modifier for general reactivity, based off of heat. Cant go below 1
	var/temperature_mult = 1
	/// The current air contents of this device
	var/datum/gas_mixture/air_contents

/obj/machinery/power/fission_reactor/examine(mob/user)
	. = ..()
	if(!(stat & BROKEN))
		return
	. += "A burning hole where the NGCR Reactor housed its core. Its inoperable in this state. The acrid smell permeates through even the thickest of suits."
	. += ""


/obj/machinery/power/fission_reactor/examine_more(mob/user)
	. = ..()
	. += "The NGCR-5600 Nuclear Reactor was first actualized as a replacement for older, static nuclear or coal models before the discovery of supermatter harvesting techniques. \
	This reactor became widespread due to the modularity and ease of use of existing station materials, allowing it to be inserted into most stations that posessed basic engineering infrastructure."
	. += ""
	. += "However, despite the popularity of the engine, the need for frequent upkeep and higher energy demands led to innovations in newer, more advanced energy sources. \
	This engine soon became a relic of the past, but still remains a staple in many stations due to its long term reliability. According to Nanotrasen, that is."

/obj/machinery/power/fission_reactor/Initialize(mapload)
	. = ..()
	AddComponent(/datum/component/multitile, list(
		list(1, MACH_CENTER, 1),
	))
	air_contents = new
	air_contents.volume = 10000 // kpa
	build_reactor_network()

/obj/machinery/power/fission_reactor/ex_act(severity)
	if(severity == EXPLODE_DEVASTATE) // Very sturdy.
		set_broken()

/obj/machinery/power/fission_reactor/blob_act(obj/structure/blob/B)
	if(prob(20))
		set_broken()

/obj/machinery/power/fission_reactor/zap_act(power, zap_flags)
	. = ..()
	if(zap_flags & ZAP_MACHINE_EXPLOSIVE)
		qdel(src)//like the singulo, tesla deletes it. stops it from exploding over and over

// This shouldnt happen normally
/obj/machinery/power/fission_reactor/Destroy()
	investigate_log("was destroyed!", INVESTIGATE_REACTOR)
	clear_reactor_network()
	return ..()

/obj/machinery/power/fission_reactor/proc/build_reactor_network()
	for(var/turf/T in RECT_TURFS(1, 2, src))
		for(var/obj/machinery/reactor_chamber/chamber in T)
			if(!chamber.linked_reactor)
				chamber.form_link(src)


/obj/machinery/power/fission_reactor/proc/clear_reactor_network()
	for(var/obj/machinery/reactor_chamber/linked in connected_chambers)
		linked.linked_reactor = null
		connected_chambers -= linked
	if(length(connected_chambers))
		log_debug("clear_reactor_network ran successfully, however connected_chambers still contains items!")

/obj/machinery/power/fission_reactor/proc/set_broken()
	if(stat & BROKEN)
		return
	overlays = null
	INVOKE_ASYNC(src, PROC_REF(meltdown))
	stat |= BROKEN

/obj/machinery/power/fission_reactor/proc/meltdown()
	icon_state = "meltdown"
	sleep(1.7 SECONDS)
	#warn Set this to be based off reactivity later
	explosion(src.loc, 10, 15, 20, ignorecap = TRUE, smoke = TRUE)
	icon_state = "broken"

/obj/machinery/power/fission_reactor/proc/set_fixed()
	stat &= ~BROKEN

/obj/machinery/power/fission_reactor/process()
	if(stat & BROKEN)
		return

/obj/machinery/reactor_chamber
	name = "Rod Housing Chamber"
	desc = "A chamber used to house nuclear rods of various types to facilitate a fission reaction."
	icon = 'icons/obj/fission/reactor_parts.dmi'
	icon_state = "chamber_down"
	anchored = TRUE
	density = FALSE
	resistance_flags = LAVA_PROOF | FIRE_PROOF | UNACIDABLE | ACID_PROOF | FREEZE_PROOF

	/// Each reactor chamber can only be linked to a single reactor, if somehow theres two.
	var/linked_reactor
	/// holds the specific rod inserted into the chamber
	var/held_rod
	/// Is the chamber up, down, or open
	var/chamber_state = 1

/obj/machinery/reactor_chamber/Initialize(mapload)
	. = ..()
	dupe_check()

// we only want it searching for a link when it is constructed, otherwise the reactor starts this.
/obj/machinery/reactor_chamber/on_construction()
	. = ..()
	find_link()

// check for multiple on a tile and nuke it
/obj/machinery/reactor_chamber/proc/dupe_check()
	var/chambers_found = 0
	for(var/obj/machinery/reactor_chamber/chamber in range(0, src))
		chambers_found++
		if(chambers_found > 1)
			visible_message("[src] has no room to deploy and breaks apart!")
			chamber.deconstruct()

/obj/machinery/reactor_chamber/attack_hand(mob/user)
	if(issilicon(user) && !Adjacent(user))
		return

	if(chamber_state == CHAMBER_DOWN)
		chamber_state = CHAMBER_UP
		icon_state = "chamber_up"
		density = TRUE

/// Forms the two-way link between the reactor and the chamber, then spreads it
/obj/machinery/reactor_chamber/proc/form_link(var/obj/machinery/power/fission_reactor/reactor)
	if(linked_reactor) // A check to prevent duplicates
		return
	linked_reactor = reactor
	reactor.connected_chambers += src
	spread_link(reactor)

/// Will spread the linked reactor to other nearby chambers
/obj/machinery/reactor_chamber/proc/spread_link(var/obj/machinery/power/fission_reactor/reactor)
	var/turf/nearby_turf
	var/direction = 0
	while(direction <= 8)
		direction++
		if(IS_DIR_CARDINAL(direction))
			nearby_turf = get_step(src, direction)
			for(var/obj/machinery/reactor_chamber/chamber in nearby_turf.contents)
				if(!chamber.linked_reactor)
					chamber.form_link(reactor)


/// Proc called when a chamber is first built
/obj/machinery/reactor_chamber/proc/find_link()
	var/turf/nearby_turf
	var/direction = 0
	while(direction <= 8)
		direction++
		if(IS_DIR_CARDINAL(direction))
			nearby_turf = get_step(src, direction)
			for(var/obj/machinery/power/fission_reactor/reactor in nearby_turf.contents)
				form_link(reactor)
				return
			for(var/obj/machinery/reactor_chamber/chamber in nearby_turf.contents)
				if(chamber.linked_reactor)
					linked_reactor = chamber.linked_reactor
					spread_link(linked_reactor)
					return

/obj/item/circuitboard/machine/reactor_chamber
	board_name = "Reactor Chamber"
	icon_state = "engineering"
	build_path = /obj/machinery/reactor_chamber
	board_type = "machine"
	origin_tech = "engineering=2"
	req_components = list(
		/obj/item/stack/cable_coil = 5,
		/obj/item/stack/sheet/metal = 10,
		/obj/item/stack/sheet/mineral/plastitanium = 10,
	)

/obj/machinery/atmospherics/unary/reactor_gas_node
	name = "Reactor Gas Intake"
	desc = "A sturdy-looking gas inlet that injects gas into the reactor"
	icon = 'icons/obj/fission/reactor_parts.dmi'
	icon_state = "gas_node"
	layer = GAS_PIPE_VISIBLE_LAYER
	max_integrity = 2000
	density = FALSE
	target_pressure = 9500 // maximum "normal" pressure in KPA
	can_unwrench = FALSE

	/// Hold which reactor the intake is connected to.
	var/obj/machinery/power/fission_reactor/linked_reactor
	/// Is this vent taking air in or out. TRUE by default.
	var/intake_vent = TRUE

/obj/machinery/atmospherics/unary/reactor_gas_node/output
	name = "Reactor Gas Extractor"
	intake_vent = FALSE

/obj/machinery/atmospherics/unary/reactor_gas_node/Initialize(mapload)
	. = ..()
	for(var/obj/machinery/power/fission_reactor/reactor in range(src, 1))
		linked_reactor = reactor
	initialize_directions = dir

/obj/machinery/atmospherics/unary/reactor_gas_node/process_atmos()
	if(stat & (NOPOWER|BROKEN))
		return FALSE
	if(!linked_reactor)
		return FALSE
	var/datum/gas_mixture/network1
	var/datum/gas_mixture/network2

	if(intake_vent)
		network1 = linked_reactor.air_contents
		network2 = air_contents
	if(!intake_vent)
		network1 = air_contents
		network2 = linked_reactor.air_contents

	if(!network1 || !network2)
		return

	// this is basically passive gate code
	var/output_starting_pressure = network1.return_pressure()
	var/input_starting_pressure = network2.return_pressure()
	if(output_starting_pressure >= min(target_pressure, input_starting_pressure - 10))
		//No need to pump gas if target is already reached or input pressure is too low
		//Need at least 10 KPa difference to overcome friction in the mechanism
		return 1

	//Calculate necessary moles to transfer using PV = nRT
	if((network2.total_moles() > 0) && (network2.temperature() > 0))
		var/pressure_delta = min(target_pressure - output_starting_pressure, (input_starting_pressure - output_starting_pressure) / 2)

		var/transfer_moles = pressure_delta * network1.volume / (network2.temperature() * R_IDEAL_GAS_EQUATION)

		//Actually transfer the gas
		var/datum/gas_mixture/removed = network2.remove(transfer_moles)
		network1.merge(removed)

		parent.update = 1

	return 1

/obj/machinery/atmospherics/unary/reactor_gas_node/wrench_act(mob/user, obj/item/I)
	var/list/choices = list("West" = WEST, "East" = EAST, "South" = SOUTH, "North" = NORTH)
	var/selected = tgui_input_list(user, "Select a direction for the connector.", "Connector Direction", choices)
	if(!selected)
		return
	if(!I.use_tool(src, user, 1 SECONDS, volume = I.tool_volume))
		return
	if(!Adjacent())
	dir = choices[selected]
	var/node_connect = dir
	initialize_directions = dir
	for(var/obj/machinery/atmospherics/target in get_step(src,node_connect))
		if(target.initialize_directions & get_dir(target,src))
			node = target
			break
	initialize_atmos_network()
	linked_reactor = null
	var/turf/T = get_step(src, REVERSE_DIR(dir))
	for(var/obj/machinery/power/fission_reactor/reactor in T)
		linked_reactor = reactor
	for(var/obj/structure/filler/filler in T)
		if(istype(filler.parent, /obj/machinery/power/fission_reactor))
			linked_reactor = filler.parent
	T = get_step(src, REVERSE_DIR(dir))
	update_icon()
	return

/obj/machinery/atmospherics/unary/reactor_gas_node/multitool_act(mob/living/user, obj/item/I)
	if(do_after_once(user, 1 SECONDS, TRUE, src))
		intake_vent = !intake_vent
		if(intake_vent)
			name = "Reactor Gas Intake"
		else
			name = "Reactor Gas Extractor"
	return ..()



#undef REACTOR_NEEDS_DIGGING
#undef REACTOR_NEEDS_CROWBAR
#undef REACTOR_NEEDS_PLASTITANIUM
#undef REACTOR_NEEDS_SCREWDRIVER
#undef REACTOR_NEEDS_WELDING
#undef REACTOR_NEEDS_PLASTEEL
#undef REACTOR_NEEDS_WRENCH
