// the steps for repairing the reactor
#define REACTOR_NEEDS_DIGGING 		1
#define REACTOR_NEEDS_CROWBAR 		2
#define REACTOR_NEEDS_PLASTITANIUM	3
#define REACTOR_NEEDS_SCREWDRIVER	4
#define REACTOR_NEEDS_WELDING		5
#define REACTOR_NEEDS_PLASTEEL		6
#define REACTOR_NEEDS_WRENCH		7

/obj/machinery/power/fission_reactor
	name = "Nuclear Fission Reactor"
	desc = "An ancient yet reliable form of power generation utilising fissile materials to generate heat."
	icon = 'icons/goonstation/objects/reactor.dmi'
	icon_state = "reactor_off"
	anchored = TRUE
	density = TRUE
	resistance_flags = INDESTRUCTIBLE | LAVA_PROOF | FIRE_PROOF | UNACIDABLE | ACID_PROOF | FREEZE_PROOF
	pixel_x = -16

	/// Holds the list for the connected reactor chambers to take data from
	var/list/connected_chambers = list()
	/// Prevents the reactor from making power under certain circumstances
	var/can_create_power = TRUE
	/// The total amount of heat gathered in the reactor
	var/total_heat
	/// The total amount of power being generated by the engine (in watts)
	var/total_power
	/// The user-controlled rods used to change how active the reactor is
	var/control_rod_percentage = 0
	/// A modifier for general reactivity, based off of heat. Cant go below 1
	var/temperature_mult = 1
	/// The current air contents of this device
	var/datum/gas_mixture/air_contents

/obj/machinery/power/fission_reactor/examine(mob/user)
	. = ..()
	if(!(stat & BROKEN))
		return
	. += "A burning hole where the NGCR Reactor housed its core. Its inoperable in this state. The acrid smell permeates through even the thickest of suits."
	. += ""


/obj/machinery/power/fission_reactor/examine_more(mob/user)
	. = ..()
	. += "The NGCR-5600 Nuclear Reactor was first actualized as a replacement for older, static nuclear or coal models before the discovery of supermatter harvesting techniques. \
	This reactor became widespread due to the modularity and ease of use of existing station materials, allowing it to be inserted into most stations that posessed basic engineering infrastructure."
	. += ""
	. += "However, despite the popularity of the engine, the need for frequent upkeep and higher energy demands led to innovations in newer, more advanced energy sources. \
	This engine soon became a relic of the past, but still remains a staple in many stations due to its long term reliability. According to Nanotrasen, that is."

/obj/machinery/power/fission_reactor/Initialize(mapload)
	. = ..()
	AddComponent(/datum/component/multitile, list(
		list(1, MACH_CENTER, 1),
	))
	build_reactor_network()

/obj/machinery/power/fission_reactor/ex_act(severity)
	if(severity == EXPLODE_DEVASTATE) // Very sturdy.
		set_broken()

/obj/machinery/power/fission_reactor/blob_act(obj/structure/blob/B)
	if(prob(20))
		set_broken()

/obj/machinery/power/fission_reactor/zap_act(power, zap_flags)
	. = ..()
	if(zap_flags & ZAP_MACHINE_EXPLOSIVE)
		qdel(src)//like the singulo, tesla deletes it. stops it from exploding over and over

// This shouldnt happen normally
/obj/machinery/power/fission_reactor/Destroy()
	investigate_log("was destroyed!", INVESTIGATE_REACTOR)
	clear_reactor_network()
	return ..()

/obj/machinery/power/fission_reactor/proc/build_reactor_network()
	for(var/turf/T in RECT_TURFS(1, 2, src))
		for(var/obj/machinery/reactor_chamber/chamber in T)
			if(!chamber.linked_reactor)
				chamber.form_link(src)


/obj/machinery/power/fission_reactor/proc/clear_reactor_network()
	for(var/obj/machinery/reactor_chamber/linked in connected_chambers)
		linked.linked_reactor = null
		connected_chambers -= linked
	if(length(connected_chambers))
		log_debug("clear_reactor_network ran successfully, however connected_chambers still contains items!")

/obj/machinery/power/fission_reactor/proc/set_broken()
	if(stat & BROKEN)
		return
	overlays = null
	INVOKE_ASYNC(src, PROC_REF(meltdown))
	stat |= BROKEN

/obj/machinery/power/fission_reactor/proc/meltdown()
	icon_state = "meltdown"
	sleep(1.7 SECONDS)
	#warn Set this to be based off reactivity later
	explosion(src.loc, 10, 15, 20, ignorecap = TRUE, smoke = TRUE)
	icon_state = "broken"

/obj/machinery/power/fission_reactor/proc/set_fixed()
	stat &= ~BROKEN

/obj/machinery/power/fission_reactor/process()
	if(stat & BROKEN)
		return

/obj/machinery/reactor_chamber
	name = "Rod Housing Chamber"
	desc = "A chamber used to house nuclear rods of various types to facilitate a fission reaction."
	icon = 'icons/obj/fission/reactor_parts.dmi'
	icon_state = "injector"
	anchored = TRUE
	density = FALSE
	resistance_flags = LAVA_PROOF | FIRE_PROOF | UNACIDABLE | ACID_PROOF | FREEZE_PROOF

	/// Each reactor chamber can only be linked to a single reactor, if somehow theres two.
	var/linked_reactor
	/// holds the specific rod inserted into the chamber
	var/held_rod

/obj/machinery/reactor_chamber/Initialize(mapload)
	. = ..()
	var/chambers_found = 0
	for(var/obj/machinery/reactor_chamber/chamber in range(0, src))
		chambers_found++
		if(chambers_found > 1)
			chamber.deconstruct()

// we only want it searching for a link when it is constructed, otherwise the reactor starts this.
/obj/machinery/reactor_chamber/on_construction()
	. = ..()
	find_link()

/// Forms the two-way link between the reactor and the chamber, then spreads it
/obj/machinery/reactor_chamber/proc/form_link(var/obj/machinery/power/fission_reactor/reactor)
	if(linked_reactor) // A check to prevent duplicates
		return
	linked_reactor = reactor
	reactor.connected_chambers += src
	spread_link(reactor)

/// Will spread the linked reactor to other nearby chambers
/obj/machinery/reactor_chamber/proc/spread_link(var/obj/machinery/power/fission_reactor/reactor)
	var/turf/nearby_turf
	var/direction = 0
	while(direction <= 8)
		direction++
		if(IS_DIR_CARDINAL(direction))
			nearby_turf = get_step(src, direction)
			for(var/obj/machinery/reactor_chamber/chamber in nearby_turf.contents)
				if(!chamber.linked_reactor)
					chamber.form_link(reactor)


/// Proc called when a chamber is first built
/obj/machinery/reactor_chamber/proc/find_link()
	var/turf/nearby_turf
	var/direction = 0
	while(direction <= 8)
		direction++
		if(IS_DIR_CARDINAL(direction))
			nearby_turf = get_step(src, direction)
			for(var/obj/machinery/power/fission_reactor/reactor in nearby_turf.contents)
				form_link(reactor)
				return
			for(var/obj/machinery/reactor_chamber/chamber in nearby_turf.contents)
				if(chamber.linked_reactor)
					linked_reactor = chamber.linked_reactor
					spread_link(linked_reactor)
					return

/obj/item/circuitboard/machine/reactor_chamber
	board_name = "Reactor Chamber"
	icon_state = "engineering"
	build_path = /obj/machinery/reactor_chamber
	board_type = "machine"
	origin_tech = "engineering=2"
	req_components = list(
		/obj/item/stack/cable_coil = 5,
		/obj/item/stack/sheet/metal = 10,
		/obj/item/stack/sheet/mineral/plastitanium = 10,
	)

/obj/machinery/atmospherics/unary/reactor_gas_node
	name = "Reactor Gas Intake"
	desc = "A sturdy-looking gas inlet that injects gas into the reactor"
	icon = 'icons/atmos/pump.dmi'
	icon_state = "map_off"
	layer = GAS_PIPE_VISIBLE_LAYER
	max_integrity = 2000
	density = FALSE
	target_pressure = 9500 // maximum "normal" pressure in KPA
	can_unwrench = FALSE

	/// Hold which reactor the intake is connected to.
	var/obj/machinery/power/fission_reactor/linked_reactor
	/// Is this vent taking air int or out
	var/intake_vent

/obj/machinery/atmospherics/unary/reactor_gas_node/Initialize(mapload)
	. = ..()
	for(var/obj/machinery/power/fission_reactor/reactor in range(src, 1))
		linked_reactor = reactor

/obj/machinery/atmospherics/unary/reactor_gas_node/process_atmos()
	if(stat & (NOPOWER|BROKEN))
		return FALSE

	var/datum/gas_mixture/network1
	var/datum/gas_mixture/network2

	if(intake_vent)
		network1 = linked_reactor.air_contents
		network2 = air_contents
	if(!intake_vent)
		network1 = air_contents
		network2 = linked_reactor.air_contents

	// this is basically passive gate code
	var/output_starting_pressure = network1.return_pressure()
	var/input_starting_pressure = network2.return_pressure()
	if(output_starting_pressure >= min(target_pressure,input_starting_pressure - 10))
		//No need to pump gas if target is already reached or input pressure is too low
		//Need at least 10 KPa difference to overcome friction in the mechanism
		return 1
	if(target_pressure >= input_starting_pressure - 10)
		//Gas will not pump if the input pressure is lower than the target
		return 1

	//Calculate necessary moles to transfer using PV = nRT
	if((network2.total_moles() > 0) && (network2.temperature() > 0))
		var/pressure_delta = min(target_pressure - output_starting_pressure, (input_starting_pressure - output_starting_pressure) / 2)

		var/transfer_moles = pressure_delta * network1.volume / (network2.temperature() * R_IDEAL_GAS_EQUATION)

		//Actually transfer the gas
		var/datum/gas_mixture/removed = network2.remove(transfer_moles)
		network1.merge(removed)

		parent.update = 1

	return 1

/obj/machinery/atmospherics/unary/reactor_gas_node/item_interaction(mob/living/user, obj/item/used, list/modifiers)
	if(linked_reactor)
		to_chat(user, "<span class='alert'>The gas node is already linked </span>")
		return
	if(default_change_direction_wrench(user, used))
		linked_reactor = null
		var/turf/T = get_step(src, dir)
		for(var/obj/machinery/power/fission_reactor/reactor in T.contents)
			intake_vent = FALSE
			linked_reactor = reactor
		T = get_step(src, REVERSE_DIR(dir))
		for(var/obj/machinery/power/fission_reactor/reactor in T.contents)
			intake_vent = TRUE
			linked_reactor = reactor
		update_icon(UPDATE_OVERLAYS)
