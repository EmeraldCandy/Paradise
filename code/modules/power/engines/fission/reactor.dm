// the steps for repairing the reactor
#define REACTOR_NEEDS_DIGGING 		1
#define REACTOR_NEEDS_CROWBAR 		2
#define REACTOR_NEEDS_PLASTITANIUM	3
#define REACTOR_NEEDS_WRENCH		4
#define REACTOR_NEEDS_WELDING		5
#define REACTOR_NEEDS_PLASTEEL		6
#define REACTOR_NEEDS_SCREWDRIVER	7


// The states of reactor chambers
#define CHAMBER_DOWN	 1
#define CHAMBER_UP		 2
#define CHAMBER_OPEN	 3

#define REACTOR_LIGHT_COLOR "#569fff"
#define TOTAL_CONTROL_RODS 5 // The max number of control rods
#define AVERAGE_HEAT_THRESHOLD 10 // The threshold the average heat-per-rod must exceed to generate coefficient
#define TOTAL_HEAT_THRESHOLD 600
#define HEAT_CONVERSION_RATIO 200

#warn Idea todo: Allow grilling on an active reactor
#warn Idea todo: Allow CC to unlock for nuking station
#warn Idea todo: Make some lavaland loot into special rods/upgrades
#warn Idea todo: Bananium rods?
#warn Idea todo: syndicate meltdown rods
#warn Idea todo: Make chambers weldable
#warn Idea todo: Make chambers self-weld at high temps
#warn Idea todo: Control rods break slowly at high temps
#warn Idea todo: Reactor leaks heat at high temperatures
#warn Idea todo: ripley grippers can pick up rods without damage
#warn Idea todo: coolant rods can eject from the reactor at high temps
#warn Idea todo: Grenades that force start rods
#warn Prevent malf AI from using powers on the main reactor

/// MARK: Fission Reactor

/obj/machinery/power/fission_reactor
	name = "Nuclear Fission Reactor"
	desc = "An ancient yet reliable form of power generation utilising fissile materials to generate heat."
	icon = 'icons/goonstation/objects/reactor.dmi'
	icon_state = "reactor_off"
	anchored = TRUE
	density = TRUE
	resistance_flags = INDESTRUCTIBLE | LAVA_PROOF | FIRE_PROOF | UNACIDABLE | ACID_PROOF | FREEZE_PROOF
	pixel_x = -16

	/// Holds the list for the connected reactor chambers to take data from
	var/list/connected_chambers = list()
	/// Prevents the reactor from making power under certain circumstances
	var/can_create_power = TRUE
	/// The total amount of heat gathered in the reactor
	var/final_heat
	/// The total amount of power being generated by the engine (in watts)
	var/final_power
	/// The user-controlled rods used to change how active the reactor is
	var/control_rod_percentage = 0
	/// A modifier for general reactivity, based off of heat production. Cant go below 1
	var/reactivity_multiplier = 1
	/// The current air contents of this device
	var/datum/gas_mixture/air_contents
	/// How many functional control rods does the reactor have?
	var/control_rods_remaining = 5
	/// what repair step is the reactor on?
	var/repair_step = 1
	/// the desired percentage the engineers set the reactor control rods
	var/desired_power = 0
	/// What percentage are the reactor control rods running at? Minimum raised for each broken control rod
	var/operating_power = 0
	///The amount of damage we have currently
	var/damage = 0
	///The point at which we delam
	var/explosion_point = 900
	/// Is this the primary station engine that spawns in round? Basically
	var/primary_engine = FALSE
	/// Has the engine warmed up enough to start
	var/starting_up = TRUE
	/// Is the engine currently fully offline
	var/offline = TRUE

/obj/machinery/power/fission_reactor/roundstart
	primary_engine = TRUE

/obj/machinery/power/fission_reactor/examine(mob/user)
	. = ..()
	if(!(stat & BROKEN))
		return
	. += "A burning hole remains where the NGCR Reactor housed its core. Its inoperable in this state. The acrid smell permeates through even the thickest of suits."
	. += ""


/obj/machinery/power/fission_reactor/examine_more(mob/user)
	. = ..()
	. += "The NGCR-5600 Nuclear Reactor was first actualized as a replacement for older, static nuclear or coal models before the discovery of supermatter harvesting techniques. \
	This reactor became widespread due to the modularity and ease of use of existing station materials, allowing it to be inserted into most stations that posessed basic engineering infrastructure."
	. += ""
	. += "However, despite the popularity of the engine, the need for frequent upkeep and higher energy demands led to innovations in newer, more advanced energy sources. \
	This engine soon became a relic of the past, but still remains a staple in many stations due to its long term reliability. According to Nanotrasen, that is."

/obj/machinery/power/fission_reactor/Initialize(mapload)
	. = ..()
	AddComponent(/datum/component/multitile, list(
		list(1, MACH_CENTER, 1),
	))
	air_contents = new
	air_contents.volume = 1000 // kpa
	if(primary_engine)
		GLOB.main_fission_reactor = src
	build_reactor_network()
	connect_to_network()

/obj/machinery/power/fission_reactor/ex_act(severity)
	if(severity == EXPLODE_DEVASTATE) // Very sturdy.
		set_broken()

/obj/machinery/power/fission_reactor/blob_act(obj/structure/blob/B)
	if(prob(20))
		set_broken()

/obj/machinery/power/fission_reactor/zap_act(power, zap_flags)
	. = ..()
	if(zap_flags & ZAP_MACHINE_EXPLOSIVE)
		qdel(src)//like the singulo, tesla deletes it. stops it from exploding over and over

// This shouldnt happen normally
/obj/machinery/power/fission_reactor/Destroy()
	investigate_log("was destroyed!", INVESTIGATE_REACTOR)
	clear_reactor_network()
	return ..()

/// Links all valid chambers to the reactor itself.
/obj/machinery/power/fission_reactor/proc/build_reactor_network()
	for(var/turf/T in RECT_TURFS(1, 2, src))
		for(var/obj/machinery/reactor_chamber/chamber in T)
			if(!chamber.linked_reactor && !chamber.skip_link)
				chamber.form_link(src)


/obj/machinery/power/fission_reactor/proc/clear_reactor_network(var/restart = FALSE)
	for(var/obj/machinery/reactor_chamber/linked in connected_chambers)
		linked.linked_reactor = null
		connected_chambers -= linked
	if(length(connected_chambers))
		log_debug("clear_reactor_network ran successfully, however connected_chambers still contains items!")
		connected_chambers.Cut()
	if(restart)
		build_reactor_network()

/obj/machinery/power/fission_reactor/proc/set_broken()
	if(stat & BROKEN)
		return
	overlays = null
	clear_reactor_network()
	INVOKE_ASYNC(src, PROC_REF(meltdown))
	stat |= BROKEN

/obj/machinery/power/fission_reactor/proc/meltdown()
	icon_state = "meltdown"
	sleep(1.7 SECONDS)
	#warn Set this to be based off reactivity later
	explosion(src.loc, 5, 15, 20, ignorecap = TRUE, smoke = TRUE)
	icon_state = "broken"

/obj/machinery/power/fission_reactor/proc/set_fixed()
	stat &= ~BROKEN
	icon = "reactor_off"
	build_reactor_network()

/obj/machinery/power/fission_reactor/item_interaction(mob/living/user, obj/item/used, list/modifiers)
	. = ..()
	if(!(stat & BROKEN))
		return
	if(istype(used, /obj/item/shovel) && repair_step == REACTOR_NEEDS_DIGGING)
		playsound(src, used.usesound, 50, 1)
		if(do_after_once(user, 3 SECONDS, TRUE, src, allow_moving = FALSE))
			playsound(src, used.usesound, 50, 1)
			new /obj/item/slag(loc)
			if(prob(30))
				repair_step++
				to_chat(user, "<span class='information'>There seems to be more slag clogging the ruined reactor core.</span>")
			else
				to_chat(user, "<span class='information'>No more melted slag remains in the chamber</span>")
		return ITEM_INTERACT_COMPLETE
	if(istype(used, /obj/item/stack/sheet/mineral/plastitanium) && repair_step == REACTOR_NEEDS_PLASTITANIUM)
		var/obj/item/stack/sheet/plastitanium = used
		if(plastitanium.amount >= 10)
			if(do_after_once(user, 3 SECONDS, TRUE, src, allow_moving = FALSE))
				to_chat(user, "<span class='information'>You reform the control rod housing and slot the structure into place.</span>")
				repair_step++
		else
			to_chat(user, "<span class='warning'>You need at least ten sheets of plastitanium to reform the reactor core structure!</span>")
		return ITEM_INTERACT_COMPLETE
	if(istype(used, /obj/item/stack/sheet/plasteel) && repair_step == REACTOR_NEEDS_PLASTEEL)
		var/obj/item/stack/sheet/plasteel = used
		if(plasteel.amount >= 5)
			if(do_after_once(user, 3 SECONDS, TRUE, src, allow_moving = FALSE))
				repair_step++
				to_chat(user, "<span class='information'>You attach a layer of radiation shielding around the reactor core.</span>")
		else
			to_chat(user, "<span class='warning'>You need at least five sheets of plastitanium to reform the reactor core structure!</span>")
		return ITEM_INTERACT_COMPLETE

/obj/machinery/power/fission_reactor/crowbar_act(mob/living/user, obj/item/I)
	if(repair_step == REACTOR_NEEDS_CROWBAR)
		if(I.use_tool(src, user, 1 SECONDS, volume = 50))
			playsound(src, I.usesound, 50, 1)
			repair_step++
			to_chat(user, "<span class='information'>You remove any remaining damaged structure from the housing.</span>")
			new /obj/item/stack/sheet/metal(user.loc, 2)
		return ITEM_INTERACT_COMPLETE

/obj/machinery/power/fission_reactor/wrench_act(mob/living/user, obj/item/I)
	if(repair_step == REACTOR_NEEDS_WRENCH)
		if(I.use_tool(src, user, 1 SECONDS, volume = 50))
			playsound(src, I.usesound, 50, 1)
			repair_step++
			to_chat(user, "<span class='information'>You secure the new plastitanium structure in place.</span>")
			new /obj/item/stack/sheet/metal(user.loc, 2)
		return ITEM_INTERACT_COMPLETE

/obj/machinery/power/fission_reactor/screwdriver_act(mob/living/user, obj/item/I)
	if(repair_step == REACTOR_NEEDS_SCREWDRIVER)
		if(I.use_tool(src, user, 1 SECONDS, volume = 50))
			playsound(src, I.usesound, 50, 1)
			to_chat(user, "<span class='information'>You secure the radiation shielding into place.</span>")
			set_fixed()
		return ITEM_INTERACT_COMPLETE

/obj/machinery/power/fission_reactor/welder_act(mob/living/user, obj/item/I)
	if(repair_step == REACTOR_NEEDS_WELDING)
		if(I.use_tool(src, user, 1 SECONDS, volume = 50))
			playsound(src, I.usesound, 50, 1)
			repair_step++
			to_chat(user, "<span class='information'>You weld together the framing, ensuring an airtight seal within the core.</span>")
			new /obj/item/stack/sheet/metal(user.loc, 2)
		return ITEM_INTERACT_COMPLETE

/obj/machinery/power/fission_reactor/proc/get_status()
	if(!air_contents) // this shouldnt happen, but just in case it does...
		return SUPERMATTER_ERROR
	if(offline)
		return SUPERMATTER_INACTIVE
	else
		return SUPERMATTER_NORMAL

/obj/machinery/power/fission_reactor/proc/get_integrity()
	var/integrity = damage / explosion_point
	integrity = round(100 - integrity * 100, 0.01)
	integrity = integrity < 0 ? 0 : integrity
	return integrity

/obj/machinery/power/fission_reactor/multitool_act(mob/living/user, obj/item/I)
	if(!I.use_tool(src, user, 0, volume = I.tool_volume))
		return
	var/obj/item/multitool/multi = I
	multi.set_multitool_buffer(user, src)

/obj/machinery/power/fission_reactor/process()
	if(stat & BROKEN)
		return
	if(!offline && !starting_up)
		var/light_power = clamp((final_power / (100 KW)), 2, 15)
		set_light(light_power, 4, REACTOR_LIGHT_COLOR)
	else
		remove_light()
	if(!length(connected_chambers))
		return

	if(desired_power > operating_power)
		operating_power++
	else if(desired_power < operating_power)
		var/minimum_power = 100 * (1 - (control_rods_remaining / TOTAL_CONTROL_RODS))
		if(operating_power > minimum_power) // oops, control rods stuck
			operating_power--

	if(operating_power == desired_power && desired_power == 0 && offline != TRUE)
		shut_off()

	if(operating_power > 0 && offline == TRUE)
		boot_up()

	if(operating_power >= 10 && starting_up == TRUE)
		become_operational()

	if(offline || starting_up)
		return

	final_power = 0
	final_heat = 0

	// lower operating power = more durability
	var/durability_loss = round(100 / ((95 / (1 + NUM_E ** (0.08 * (-operating_power + 60)))) + 10), 0.01)
	for(var/obj/machinery/reactor_chamber/chamber in connected_chambers)
		if(!chamber.held_rod)
			continue
		if(chamber.chamber_state == CHAMBER_OPEN)
			continue
		var/durability_mod = clamp(1.5 * (chamber.held_rod.durability / chamber.held_rod.max_durability) - 0.25, 0.25, 1)
		if(chamber.chamber_state == CHAMBER_DOWN) // We generate heat but not power while its down.
			final_power += chamber.power_total * durability_mod
		final_heat += chamber.heat_total * durability_mod
		chamber.held_rod.durability -= durability_loss

	final_heat *= ((operating_power / 100) * (reactivity_multiplier * 2) * HEAT_MODIFIER) // proportionally affects heat more
	final_power *= ((operating_power / 100) * reactivity_multiplier)

	var/temp = air_contents.temperature()
	var/average_heatgen = final_heat / length(connected_chambers)
	if(average_heatgen > AVERAGE_HEAT_THRESHOLD)
		reactivity_multiplier = 1 + (average_heatgen - AVERAGE_HEAT_THRESHOLD / AVERAGE_HEAT_THRESHOLD)
	else
		reactivity_multiplier = 1
	if(temp > TOTAL_HEAT_THRESHOLD)
		reactivity_multiplier += (temp - TOTAL_HEAT_THRESHOLD) / HEAT_CONVERSION_RATIO // reactivity per 200*K over 600*K
	reactivity_multiplier = min(reactivity_multiplier, 20)

	if(!can_create_power)
		return

	produce_direct_power(final_power)
	var/heat_capacity = air_contents.heat_capacity() * 300
	if(heat_capacity)
		air_contents.set_temperature(max(air_contents.temperature() + (final_heat / heat_capacity), air_contents.temperature() + 3))


/obj/machinery/power/fission_reactor/proc/shut_off()
	starting_up = TRUE
	offline = TRUE
	can_create_power = FALSE
	icon_state = "reactor_off"
	remove_light()
	#warn add a sound here

/obj/machinery/power/fission_reactor/proc/boot_up()
	offline = FALSE
	icon_state = "reactor_starting"
	#warn add a sound here

/obj/machinery/power/fission_reactor/proc/become_operational()
	starting_up = FALSE
	offline = FALSE
	can_create_power = TRUE
	icon_state = "reactor_on"
	set_light(2, 5, REACTOR_LIGHT_COLOR)
	#warn add a sound here

/// MARK: Rod Chamber

/obj/machinery/reactor_chamber
	name = "Rod Housing Chamber"
	desc = "A chamber used to house nuclear rods of various types to facilitate a fission reaction."
	icon = 'icons/obj/fission/reactor_chamber.dmi'
	icon_state = "chamber_down"
	anchored = TRUE
	density = FALSE
	resistance_flags = LAVA_PROOF | FIRE_PROOF | UNACIDABLE | ACID_PROOF | FREEZE_PROOF
	idle_power_consumption = 100

	/// Each reactor chamber can only be linked to a single reactor, if somehow theres two.
	var/obj/machinery/power/fission_reactor/linked_reactor
	/// Holds the specific rod inserted into the chamber
	var/obj/item/nuclear_rod/held_rod
	/// Is the chamber up, down, or open
	var/chamber_state = 1
	/// Has the requirements for the rod inside this chamber been met?
	var/requirements_met = FALSE
	/// Is the rod chamber actively running and providing its effects
	var/operational = FALSE
	/// Holds the list of linked neighbors
	var/list/neighbors = list()
	/// skip this chamber when building links
	var/skip_link = FALSE
	/// The total amount of heat produced by this chamber
	var/heat_total
	/// The total amount of power produced by this rod
	var/power_total

/obj/machinery/reactor_chamber/Initialize(mapload)
	. = ..()
	dupe_check()
	component_parts = list()
	component_parts += new /obj/item/circuitboard/machine/reactor_chamber(null)
	component_parts += new /obj/item/stock_parts/manipulator(src)
	component_parts += new /obj/item/stack/sheet/mineral/plastitanium(src, 2)
	component_parts += new /obj/item/stack/sheet/metal(src, 2)
	component_parts += new /obj/item/stack/cable_coil(src, 5)
	RefreshParts()
	update_icon()
	return INITIALIZE_HINT_LATELOAD

/obj/machinery/reactor_chamber/uranium

/obj/machinery/reactor_chamber/uranium/Initialize(mapload)
	. = ..()
	held_rod = new /obj/item/nuclear_rod/fuel/uranium_238(src)

/obj/machinery/reactor_chamber/heavy_water

/obj/machinery/reactor_chamber/heavy_water/Initialize(mapload)
	. = ..()
	held_rod = new /obj/item/nuclear_rod/moderator/heavy_water(src)



// needs to be late so it does not initialize before the reactor or the other neighbors
/obj/machinery/reactor_chamber/LateInitialize()
	. = ..()
	get_neighbors()

/obj/machinery/reactor_chamber/proc/get_neighbors()
	if(length(neighbors)) // for when we need to rerun this
		neighbors.Cut()
	var/turf/nearby_turf
	for(var/direction in GLOB.cardinal)
		nearby_turf = get_step(src, direction)
		for(var/obj/machinery/reactor_chamber/chamber in nearby_turf)
			if(chamber.linked_reactor != linked_reactor)
				continue
			neighbors += chamber
			continue

// we only want it searching for a link when it is constructed, otherwise the reactor starts the link process.
/obj/machinery/reactor_chamber/on_construction()
	. = ..()
	find_link()
	for(var/obj/machinery/reactor_chamber/chamber in neighbors)
		chamber.get_neighbors()

/obj/machinery/reactor_chamber/on_deconstruction()
	if(linked_reactor)
		desync()
	return ..()

/obj/machinery/reactor_chamber/Destroy()
	if(linked_reactor)
		desync()
	return ..()

///  Removes the chamber from neighbor from its neighborss, and forces them to run status checks
/obj/machinery/reactor_chamber/proc/desync()
	if(linked_reactor)
		linked_reactor.clear_reactor_network(restart = TRUE)
	if(!length(neighbors))
		return
	for(var/obj/machinery/reactor_chamber/chamber in neighbors)
		chamber.neighbors -= src
		if(chamber.check_status())
			chamber.requirements_met = TRUE
		else
			chamber.requirements_met = FALSE


/obj/machinery/reactor_chamber/update_overlays()
	. = ..()
	if(held_rod && chamber_state == CHAMBER_OPEN)
		var/mutable_appearance/rod_overlay = mutable_appearance(layer = ABOVE_MOB_LAYER + 0.01)
		rod_overlay.icon = held_rod.icon
		rod_overlay.icon_state = held_rod.icon_state
		rod_overlay.pixel_y = 14
		. += rod_overlay
	if(held_rod && chamber_state == CHAMBER_DOWN)
		var/mutable_appearance/state_overlay = mutable_appearance(layer = BELOW_OBJ_LAYER + 0.01)
		state_overlay.icon = icon

		if(requirements_met)
			if(operational)
				state_overlay.icon_state = "green"
			else
				state_overlay.icon_state = "orange"
		else
			state_overlay.icon_state = "red"
		if(!requirements_met && operational)
			state_overlay.icon_state = "orange"

		. += state_overlay

// check for multiple on a tile and nuke it
/obj/machinery/reactor_chamber/proc/dupe_check()
	var/chambers_found = 0
	for(var/obj/machinery/reactor_chamber/chamber in range(0, src))
		chambers_found++
		if(chambers_found > 1)
			visible_message("<span class='warning'>[src] has no room to deploy and breaks apart!</span>")
			chamber.deconstruct()

/obj/machinery/reactor_chamber/attack_hand(mob/user)
	if(!user)
		return
	if((stat & NOPOWER))
		to_chat(user, "<span class='warning'> The chamber's locks wont disengage without power!</span>")
		return
	if(user.loc == loc)
		to_chat(user, "<span class='warning'>You can't raise the rod chamber while standing on it!</span>")
		return

	add_fingerprint(user)

	switch(chamber_state)
		if(CHAMBER_DOWN)
			if(!Adjacent(user))
				return
			var/delay = 1 SECONDS
			if(!linked_reactor.offline)
				delay = 8 SECONDS
			if(do_after_once(user, delay, target = src, allow_moving = FALSE))
				raise()
				return

		if(CHAMBER_UP)
			if(do_after_once(user, 2 SECONDS, target = src, allow_moving = FALSE))
				if(chamber_state != CHAMBER_UP) // so that we cant lower while in the open state
					return
				lower()
				return

		if(CHAMBER_OPEN)
			if(issilicon(user)) // handled seperately. Dont pull out this way
				return
			if(!held_rod)
				to_chat(user, "<span class='warning'>There is no rod inside of the chamber to remove!</span>")
				return
			else
				if(user.put_in_hands(held_rod))
					held_rod.add_fingerprint(user)
					held_rod = null
					playsound(loc, 'sound/machines/podopen.ogg', 50, 1)
					update_icon(UPDATE_OVERLAYS)
				else
					to_chat(user, "<span class='warning'>Your hands are currently full!</span>")
					return
	update_icon(UPDATE_OVERLAYS)

/obj/machinery/reactor_chamber/AltClick(mob/user, modifiers)
	if(!Adjacent(user))
		return
	if(chamber_state == CHAMBER_UP)
		open()
		return
	if(chamber_state == CHAMBER_OPEN)
		if(panel_open == TRUE)
			to_chat(user, "<span class='warning'>You must close the maintenance panel before the chamber can be sealed!</span>")
			return
		close()
		return

/obj/machinery/reactor_chamber/item_interaction(mob/living/user, obj/item/used, list/modifiers)
	if(issilicon(user) && get_dist(src, user) > 1)
		attack_hand(user)
		return ITEM_INTERACT_COMPLETE

	if(istype(used, /obj/item/nuclear_rod))
		if(chamber_state == CHAMBER_OPEN)
			if(!held_rod)
				if(user.transfer_item_to(used, src, force = TRUE))
					held_rod = used
					playsound(loc, 'sound/machines/podclose.ogg', 50, 1)
					update_icon(UPDATE_OVERLAYS)

/obj/machinery/reactor_chamber/screwdriver_act(mob/living/user, obj/item/I)
	if(!I.use_tool(src, user, 0, volume = 0))
		return
	. = TRUE
	if(chamber_state != CHAMBER_OPEN)
		to_chat(user, "<span class='alert'>[src] must be raised and open first!</span>")
		return
	if(!linked_reactor.offline)
		to_chat(user, "<span class='alert'>The safety locks prevent maintenance while the reactor is on!</span>")
		return
	default_deconstruction_screwdriver(user, icon_state, icon_state, I)

/obj/machinery/reactor_chamber/proc/raise()
	chamber_state = CHAMBER_UP
	icon_state = "chamber_up"
	density = TRUE
	playsound(loc, 'sound/items/deconstruct.ogg', 50, 1)
	operational = FALSE
	requirements_met = FALSE
	layer = ABOVE_MOB_LAYER
	update_icon(UPDATE_OVERLAYS)
	for(var/obj/machinery/reactor_chamber/chamber in neighbors)
		if(!chamber.held_rod)
			return
		if(chamber.check_status())
			chamber.requirements_met = TRUE
		else
			chamber.requirements_met = FALSE
		chamber.calculate_stats()

/obj/machinery/reactor_chamber/proc/lower()
	chamber_state = CHAMBER_DOWN
	icon_state = "chamber_down"
	density = FALSE
	layer = BELOW_OBJ_LAYER
	playsound(loc, 'sound/items/deconstruct.ogg', 50, 1)
	update_icon(UPDATE_OVERLAYS)
	if(!held_rod)
		return
	if(check_status())
		requirements_met = TRUE
	else
		requirements_met = FALSE
	calculate_stats()

/obj/machinery/reactor_chamber/proc/close()
	chamber_state = CHAMBER_UP
	icon_state = "chamber_up"
	playsound(loc, 'sound/machines/switch.ogg', 50, 1)
	update_icon(UPDATE_OVERLAYS)

/obj/machinery/reactor_chamber/proc/open()
	chamber_state = CHAMBER_OPEN
	icon_state = "chamber_open"
	playsound(loc, 'sound/machines/switch.ogg', 50, 1)
	update_icon(UPDATE_OVERLAYS)

/// Forms the two-way link between the reactor and the chamber, then spreads it
/obj/machinery/reactor_chamber/proc/form_link(var/obj/machinery/power/fission_reactor/reactor)
	if(linked_reactor || skip_link) // A check to prevent duplicates or unwanted chambers
		return
	linked_reactor = reactor
	reactor.connected_chambers += src
	spread_link(reactor)

/// Will spread the linked reactor to other nearby chambers
/obj/machinery/reactor_chamber/proc/spread_link(var/obj/machinery/power/fission_reactor/reactor)
	var/turf/nearby_turf
	for(var/direction in GLOB.cardinal)
		nearby_turf = get_step(src, direction)
		for(var/obj/machinery/reactor_chamber/chamber in nearby_turf.contents)
			if(!chamber.linked_reactor)
				chamber.form_link(reactor)

/// Searches for a valid reactor or linked chamber nearby
/obj/machinery/reactor_chamber/proc/find_link()
	var/turf/nearby_turf
	for(var/direction in GLOB.cardinal)
		nearby_turf = get_step(src, direction)
		for(var/obj/machinery/power/fission_reactor/reactor in nearby_turf.contents)
			form_link(reactor)
			continue
		for(var/obj/machinery/reactor_chamber/chamber in nearby_turf.contents)
			if(chamber.linked_reactor)
				linked_reactor = chamber.linked_reactor
				spread_link(linked_reactor)
				continue


/// validates that all rod requirements are being met
/obj/machinery/reactor_chamber/proc/check_status()
	if(!held_rod)
		return FALSE

	var/list/temp_requirements = held_rod.adjacent_requirements // a temporary modable holder
	if(!temp_requirements)
		return TRUE

	for(var/obj/machinery/reactor_chamber/chamber in neighbors)
		if(!chamber.operational)
			continue
		if(chamber.held_rod.type in temp_requirements)
			temp_requirements -= chamber.held_rod.type
		for(var/requirement in temp_requirements)
			if(chamber.held_rod.type in typesof(requirement))
				temp_requirements -= requirement
				break

	if(!length(temp_requirements))
		return TRUE

	return FALSE

/obj/machinery/reactor_chamber/process()
	if(chamber_state != CHAMBER_DOWN) /// we should only process reactor info when down
		return
	if(!requirements_met && !operational)
		if(check_status())
			requirements_met = TRUE
			update_icon(UPDATE_OVERLAYS)
			return
	if(requirements_met && !operational)
		if(prob(30))
			operational = TRUE
			for(var/obj/machinery/reactor_chamber/chamber in neighbors)
				if(chamber.held_rod)
					chamber.calculate_stats()
			update_icon(UPDATE_OVERLAYS)
			return
	if(!requirements_met && operational) /// if it loses requirements, it wont immediately turn off
		if(istype(held_rod.type, /obj/item/nuclear_rod/fuel))
			if(prob(1)) // Lower rate of fuel rod failures once they're already on. Good luck.
				operational = FALSE
				update_icon(UPDATE_OVERLAYS)
		else if(prob(10))
			operational = FALSE
			update_icon(UPDATE_OVERLAYS)
		return

/// Calculate how much heat and energy we should be making
/obj/machinery/reactor_chamber/proc/calculate_stats()
	power_total = held_rod.power_amount
	heat_total = held_rod.heat_amount

	for(var/obj/machinery/reactor_chamber/chamber in neighbors)
		if(!chamber.held_rod || chamber.chamber_state == CHAMBER_OPEN)
			continue
		heat_total *= held_rod.heat_amp_mod  // we generate heat even when its not operational
		if(operational && chamber.chamber_state != CHAMBER_DOWN)
			power_total *= held_rod.power_amp_mod

/obj/item/circuitboard/machine/reactor_chamber
	board_name = "Reactor Chamber"
	icon_state = "engineering"
	build_path = /obj/machinery/reactor_chamber
	board_type = "machine"
	origin_tech = "engineering=2"
	req_components = list(
		/obj/item/stack/cable_coil = 5,
		/obj/item/stack/sheet/metal = 2,
		/obj/item/stack/sheet/mineral/plastitanium = 2,
	)

/// MARK: Gas Node

/obj/machinery/atmospherics/unary/reactor_gas_node
	name = "Reactor Gas Intake"
	desc = "A sturdy-looking gas inlet that injects gas into the reactor"
	icon = 'icons/obj/fission/reactor_parts.dmi'
	icon_state = "gas_node"
	layer = GAS_PIPE_VISIBLE_LAYER
	max_integrity = 2000
	density = FALSE
	target_pressure = 9500 // maximum "normal" pressure in KPA
	can_unwrench = FALSE

	/// Hold which reactor the intake is connected to.
	var/obj/machinery/power/fission_reactor/linked_reactor
	/// Is this vent taking air in or out. TRUE by default.
	var/intake_vent = TRUE

/obj/machinery/atmospherics/unary/reactor_gas_node/output
	name = "Reactor Gas Extractor"
	intake_vent = FALSE

/obj/machinery/atmospherics/unary/reactor_gas_node/Initialize(mapload)
	. = ..()
	component_parts = list()
	component_parts += new /obj/item/circuitboard/machine/reactor_gas_node(null)
	component_parts += new /obj/item/stack/sheet/metal(src, 2)
	component_parts += new /obj/item/stack/cable_coil(src, 2)
	initialize_directions = dir
	RefreshParts()
	update_icon()
	return INITIALIZE_HINT_LATELOAD

// needs to be late so it does not initialize before the reactor
/obj/machinery/atmospherics/unary/reactor_gas_node/LateInitialize()
	. = ..()
	form_link()

/obj/machinery/atmospherics/unary/reactor_gas_node/process_atmos()
	if(stat & (NOPOWER|BROKEN))
		return FALSE
	if(!linked_reactor)
		return FALSE
	var/datum/gas_mixture/network1
	var/datum/gas_mixture/network2

	if(intake_vent)
		network1 = linked_reactor.air_contents
		network2 = air_contents
	if(!intake_vent)
		network1 = air_contents
		network2 = linked_reactor.air_contents

	if(!network1 || !network2)
		return

	// this is basically passive gate code
	var/output_starting_pressure = network1.return_pressure()
	var/input_starting_pressure = network2.return_pressure()
	if(output_starting_pressure >= min(target_pressure, input_starting_pressure - 10))
		//No need to pump gas if target is already reached or input pressure is too low
		//Need at least 10 KPa difference to overcome friction in the mechanism
		return 1

	//Calculate necessary moles to transfer using PV = nRT
	if((network2.total_moles() > 0) && (network2.temperature() > 0))
		var/pressure_delta = min(target_pressure - output_starting_pressure, (input_starting_pressure - output_starting_pressure) / 2)

		var/transfer_moles = pressure_delta * network1.volume / (network2.temperature() * R_IDEAL_GAS_EQUATION)

		//Actually transfer the gas
		var/datum/gas_mixture/removed = network2.remove(transfer_moles)
		network1.merge(removed)

		parent.update = 1

	return 1

/obj/machinery/atmospherics/unary/reactor_gas_node/wrench_act(mob/user, obj/item/I)
	var/list/choices = list("West" = WEST, "East" = EAST, "South" = SOUTH, "North" = NORTH)
	var/selected = tgui_input_list(user, "Select a direction for the connector.", "Connector Direction", choices)
	if(!selected)
		return
	if(!Adjacent(user))
		to_chat(user, "<span class='warning'>You moved away before construction was finished</span>")
	if(!I.use_tool(src, user, 1 SECONDS, volume = I.tool_volume))
		return
	if(!Adjacent(user))
		to_chat(user, "<span class='warning'>You moved away before construction was finished</span>")
		return
	dir = choices[selected]
	for(var/obj/machinery/atmospherics/target in get_step(src, dir))
		if(target.initialize_directions & get_dir(target,src))
			node = target
			break
	initialize_atmos_network()
	form_link()
	update_icon()
	return

/obj/machinery/atmospherics/unary/reactor_gas_node/proc/form_link()
	linked_reactor = null
	var/turf/T = get_step(src, REVERSE_DIR(dir))
	for(var/obj/machinery/power/fission_reactor/reactor in T)
		linked_reactor = reactor
	for(var/obj/structure/filler/filler in T)
		if(istype(filler.parent, /obj/machinery/power/fission_reactor))
			linked_reactor = filler.parent

/obj/machinery/atmospherics/unary/reactor_gas_node/multitool_act(mob/living/user, obj/item/I)
	if(do_after_once(user, 1 SECONDS, TRUE, src, allow_moving = FALSE))
		intake_vent = !intake_vent
		if(intake_vent)
			name = "Reactor Gas Intake"
		else
			name = "Reactor Gas Extractor"
	return ..()

/obj/item/circuitboard/machine/reactor_gas_node
	board_name = "Reactor Gas Node"
	icon_state = "engineering"
	build_path = /obj/machinery/atmospherics/unary/reactor_gas_node
	board_type = "machine"
	origin_tech = "engineering=2"
	req_components = list(
		/obj/item/stack/cable_coil = 2,
		/obj/item/stack/sheet/metal = 2,
	)

/obj/item/slag
	name = "radioactive slag"
	desc = "A large clump of active radioactive fuel fused with structural reactor metals."
	icon = 'icons/effects/effects.dmi'
	icon_state = "big_molten"
	move_resist = MOVE_FORCE_STRONG // Massive chunk of metal slag, shouldnt be moving it without carrying.
	w_class = WEIGHT_CLASS_HUGE
	force = 15
	throwforce = 10

/obj/item/slag/Initialize(mapload)
	. = ..()
	scatter_atom()

/// MARK: Monitor

/obj/machinery/computer/fission_monitor
	name = "NGCR monitoring console"
	desc = "Used to monitor the Nanotrasen Gas Cooled Fission Reactor."
	icon_keyboard = "power_key"
	icon_screen = "smmon_0"
	circuit = /obj/item/circuitboard/fission_monitor
	light_color = LIGHT_COLOR_YELLOW
	/// Last status of the active reactor for caching purposes
	var/last_status
	/// Reference to the active reactor
	var/obj/machinery/power/fission_reactor/active

/obj/machinery/computer/fission_monitor/Initialize(mapload)
	. = ..()
	return INITIALIZE_HINT_LATELOAD

/obj/machinery/computer/fission_monitor/LateInitialize()
	. = ..()
	active = GLOB.main_fission_reactor

/obj/machinery/computer/fission_monitor/Destroy()
	active = null
	return ..()

/obj/machinery/computer/fission_monitor/attack_ai(mob/user)
	attack_hand(user)

/obj/machinery/computer/fission_monitor/attack_hand(mob/user)
	add_fingerprint(user)
	if(stat & (BROKEN|NOPOWER))
		return
	ui_interact(user)

/obj/machinery/computer/fission_monitor/ui_state(mob/user)
	return GLOB.default_state

/obj/machinery/computer/fission_monitor/process()
	if(stat & (NOPOWER|BROKEN))
		return FALSE

	if(active)
		var/new_status = active.get_status()
		if(last_status != new_status)
			last_status = new_status
			if(last_status == SUPERMATTER_ERROR)
				last_status = SUPERMATTER_INACTIVE
			icon_screen = "smmon_[last_status]"
			update_icon()

	return TRUE

/obj/machinery/computer/fission_monitor/multitool_act(mob/living/user, obj/item/I)
	if(!I.multitool_check_buffer(user))
		return
	var/obj/item/multitool/multitool = I
	if(istype(multitool.buffer, /obj/machinery/power/fission_reactor))
		active = multitool.buffer
		to_chat(user, "<span class='notice'>You load the buffer's linking data to [src].</span>")

/obj/machinery/computer/fission_monitor/ui_interact(mob/user, datum/tgui/ui = null)
	ui = SStgui.try_update_ui(user, src, ui)
	if(!ui)
		ui = new(user, src, "ReactorMonitor", name)
		ui.open()

	return TRUE

/obj/machinery/computer/fission_monitor/ui_data(mob/user)
	var/list/data = list()
	// If we somehow dont have an engine anymore, handle it here.
	if(!active)
		active = null
		return
	if(active.stat & BROKEN)
		active = null
		return

	var/datum/gas_mixture/air = active.air_contents
	var/power_kilowatts = round((active.final_power / 1000), 1)

	data["NGCR_integrity"] = active.get_integrity()
	data["NGCR_power"] = power_kilowatts
	data["NGCR_ambienttemp"] = air.temperature()
	data["NGCR_ambientpressure"] = air.return_pressure()
	data["NGCR_coefficient"] = active.reactivity_multiplier
	data["NGCR_throttle"] = active.desired_power
	data["NGCR_operatingpower"] = active.operating_power
	var/list/gasdata = list()
	var/TM = air.total_moles()
	if(TM)
		gasdata.Add(list(list("name"= "Oxygen", "amount" = air.oxygen(), "portion" = round(100 * air.oxygen() / TM, 0.01))))
		gasdata.Add(list(list("name"= "Carbon Dioxide", "amount" = air.carbon_dioxide(), "portion" = round(100 * air.carbon_dioxide() / TM, 0.01))))
		gasdata.Add(list(list("name"= "Nitrogen", "amount" = air.nitrogen(), "portion" = round(100 * air.nitrogen() / TM, 0.01))))
		gasdata.Add(list(list("name"= "Plasma", "amount" = air.toxins(), "portion" = round(100 * air.toxins() / TM, 0.01))))
		gasdata.Add(list(list("name"= "Nitrous Oxide", "amount" = air.sleeping_agent(), "portion" = round(100 * air.sleeping_agent() / TM, 0.01))))
		gasdata.Add(list(list("name"= "Agent B", "amount" = air.agent_b(), "portion" = round(100 * air.agent_b() / TM, 0.01))))
	else
		gasdata.Add(list(list("name"= "Oxygen", "amount" = 0, "portion" = 0)))
		gasdata.Add(list(list("name"= "Carbon Dioxide", "amount" = 0,"portion" = 0)))
		gasdata.Add(list(list("name"= "Nitrogen", "amount" = 0,"portion" = 0)))
		gasdata.Add(list(list("name"= "Plasma", "amount" = 0,"portion" = 0)))
		gasdata.Add(list(list("name"= "Nitrous Oxide", "amount" = 0,"portion" = 0)))
		gasdata.Add(list(list("name"= "Agent B", "amount" = 0,"portion" = 0)))
	data["gases"] = gasdata

	return data

/obj/machinery/computer/fission_monitor/ui_act(action, list/params, datum/tgui/ui, datum/ui_state/state)
	if(..())
		return

	if(stat & (BROKEN|NOPOWER))
		return

	if(action == "set_throttle")
		active.desired_power = text2num(params["NGCR_throttle"])

/obj/machinery/computer/fission_monitor/attack_ai(mob/user)
	attack_hand(user)

#undef REACTOR_NEEDS_DIGGING
#undef REACTOR_NEEDS_CROWBAR
#undef REACTOR_NEEDS_PLASTITANIUM
#undef REACTOR_NEEDS_SCREWDRIVER
#undef REACTOR_NEEDS_WELDING
#undef REACTOR_NEEDS_PLASTEEL
#undef REACTOR_NEEDS_WRENCH

#undef CHAMBER_DOWN
#undef CHAMBER_UP
#undef CHAMBER_OPEN

#undef REACTOR_LIGHT_COLOR
